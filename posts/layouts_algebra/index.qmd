---
title: "Layout Algebra"
author: "Sean Zhang"
date: "2025-07-22"
categories: [CUDA, programming, technical]
image: "warp_tiling_perf.png"
description: "Why layouts are the fundmamental building blocks of modern GPU programming"
link-citations: true
draft: true
---


In this post, I want to share with you one of the most useful concepts in modern GPU programming: **layouts**.

# A Case Study: Copying Tensors

As a motivation, let's say we want to copy a 2D array (8-by-8) from a row-major tensor to a column-major tensor using CUDA. The tensors can be visualized as follows:

:::{.column-body-outset}
::: {.columns}
::: {.column width="50%"}****
```{python}
#| echo: false
from plotter import Layout, LayoutPlotter, T, _, Coord

l = Layout(T(8, 8), T(1, 8))
p = LayoutPlotter(l, title="Row-major")
p.show()
```
:::

::: {.column width="50%"}
```{python}
#| echo: false
from plotter import Layout, LayoutPlotter, T, _, Coord

l = Layout(T(8, 8), T(8, 1))
p = LayoutPlotter(l, title="Column-major")
p.show()
```
:::
:::
:::

*Note that the numbers in the tensors indicate the physical offset, not the data value.*

Now, we might want to split the copy operations into one of two ways:

:::{.column-body-outset}
::: {.columns}
::: {.column width="50%"}
```{python}
#| echo: false
from plotter import Layout, LayoutPlotter, T, _, Coord

l = Layout(T(8, 8), T(1, 8))
p = LayoutPlotter(l, title="Source Tensor, block-wise copy")
p.slice((0, 0), color="red").slice((0, 1), color="red").slice((0, 2), color="green").slice((0, 3), color="green").slice((0, 4), color="blue").slice((0, 5), color="blue").slice((0, 6), color="orange").slice((0, 7), color="orange").show()
```
:::

::: {.column width="50%"}
```{python}
#| echo: false
from plotter import Layout, LayoutPlotter, T, _, Coord

l = Layout(T(8, 8), T(8, 1))
p = LayoutPlotter(l, title="Source Tensor, strided copy")
p.slice((0, 0), color="red").slice((4, 0), color="red").slice((0, 1), color="green").slice((4, 1), color="green").slice((0, 2), color="blue").slice((4, 2), color="blue").slice((0, 3), color="orange").slice((4, 3), color="orange").show()
```
:::
:::
:::

Here we use color to indicate the thread that is responsible for copying the data. To understand effect of different copy strategies, we can 


**Traditional Approach**
The traditional approach is to use the physical offset to access the data, which requires passing in the shapes and strides of the source and destination tensors.
```c++
__global__ void copy_kernel(float *src, float *dst, int width, int height, int stride_x_src, int stride_y_src, int stride_x_dst, int stride_y_dst) {
    const int block_size = blockDim.x;
    const int tid = threadIdx.x;
    const int element_per_thread = width * height / block_size;
    for (int i = 0; i < element_per_thread; i++) {
        const int x = (tid * element_per_thread + i) % width;
        const int y = (tid * element_per_thread + i) / width;
        dst[y * stride_y_dst + x * stride_x_dst] = src[y * stride_y_src + x * stride_x_src];
    }
}
```

The actuall callsite might look like the following, for the transpose copy operation:

```c++
    constexpr int width = 8;
    constexpr int height = 8;
    constexpr int stride_x_src = 1;
    constexpr int stride_y_src = 8;
    constexpr int stride_x_dst = 8;
    constexpr int stride_y_dst = 1;
    constexpr int thread_num = 32;
    float *src, *dst;
    cudaMallocManaged(&src, width * height * sizeof(float));
    cudaMallocManaged(&dst, width * height * sizeof(float));
    for (int i = 0; i < width * height; i++) {
        src[i] = static_cast<float>(i);
    }
    copy_kernel<<<1, thread_num>>>(src, dst, width, height, stride_x_src, stride_y_src, stride_x_dst, stride_y_dst);
```

Even though this code works with any shape and stride, it has a few drawbacks:
1. Memory access is not coalesced, 
2. Constant memory

**Layout-Based Approach**
The layout-based approach is to 
```c++
template <typename SrcLayout, typename DstLayout, typename FrgThr>
__global__ void copy_kernel(float *src, float *dst) {
    constexpr auto l1 = SrcLayout{};
    constexpr auto l2 = DstLayout{};
    constexpr auto frgthr = FrgThr{};
    const int tid = threadIdx.x;
    #pragma unroll
    for (int i = 0; i < size<0>(FrgThr{}); i++) {
        dst[l1(frgthr(i, tid))] = src[l2(FrgThr(i, tid))];
    }
}
```

Provided the right parametes, both of these kernels can copy 

# Layouts
* Definition: shape, stride
* Nature: mapping with structured domain
* Examples: show how to interpret layouts visually
* Operations:
  * slice and dice (w/wo underscore)
  * 
* Algebra:
  * `composition`: show how 
  * `coalesce`:
  * `product`:
  * ``


# Testing Layout Plotting Functions

Now let's test our new layout plotting functions with various examples:

```{python}
from plotter import Layout, LayoutPlotter, T, _, Coord

# Test 1D Layout
print("=== Testing 1D Layout ===")
layout_1d = Layout(T(8), T(1))
plotter_1d = LayoutPlotter(layout_1d, title="1D Layout Example")
plotter_1d.show()
```

```{python}
# Test 1D Layout with slice highlighting
print("=== Testing 1D Layout with Slice ===")
layout_1d_slice = Layout(T(8), T(1))
plotter_1d_slice = LayoutPlotter(layout_1d_slice, title="1D Layout with Highlighted Slice").slice(Coord(3))
plotter_1d_slice.show()
```

```{python}
# Test 2D Layout
print("=== Testing 2D Layout ===")
layout_2d = Layout(T(4, 6), T(6, 1))  # Row-major layout
plotter_2d = LayoutPlotter(layout_2d, title="2D Layout Example (Row-Major)")
plotter_2d.show()
```

```{python}
# Test 2D Layout with slice highlighting
print("=== Testing 2D Layout with Slice ===")
layout_2d_slice = Layout(T(4, 6), T(6, 1))
plotter_2d_slice = LayoutPlotter(layout_2d_slice, title="2D Layout with Row 1 Highlighted").slice(Coord(1, _))
plotter_2d_slice.show()
```

```{python}
# Test simple 2D column layout
print("=== Testing Column-Major Layout ===")
layout_col = Layout(T(4, 6), T(1, 4))  # Column-major layout
plotter_col = LayoutPlotter(layout_col, title="2D Layout Example (Column-Major)")
plotter_col.show()
```

```{python}
# Test column layout with slice highlighting
print("=== Testing Column Layout with Slice ===")
layout_col_slice = Layout(T(4, 6), T(1, 4))
plotter_col_slice = LayoutPlotter(layout_col_slice, title="Column Layout with Column 2 Highlighted").slice(Coord(_, 2))
plotter_col_slice.show()
```

```{python}
# Test complex layout patterns
print("=== Testing Complex Layout Patterns ===")
layout_complex = Layout(T(3, 4), T(4, 1))
print(layout_complex.size())
print(layout_complex.cosize())

# Normal layout
plotter_normal = LayoutPlotter(layout_complex, title="Clean Grid Layout")
plotter_normal.show()

# Layout with slice highlighting
plotter_slice = LayoutPlotter(layout_complex, title="Grid with Row 0 Highlighted").slice(Coord(0, _))
plotter_slice.show()

# Show domain/codomain mapping for the same layout
plotter_mapping = LayoutPlotter(layout_complex, title="Layout Mapping Visualization")
plotter_mapping.show_mapping()

# Show domain/codomain mapping with slice
plotter_mapping_slice = LayoutPlotter(layout_complex, title="Layout Mapping with Slice").slice(Coord(0, _))
plotter_mapping_slice.show_mapping()
```

