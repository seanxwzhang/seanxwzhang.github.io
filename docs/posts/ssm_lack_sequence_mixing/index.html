<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sean Zhang">
<meta name="dcterms.date" content="2024-03-02">
<meta name="description" content="Every architecture contains some implicit trade-offs. My impression is SSMs are a good sequential architecture for modalities where interactions within a sequence matters less than a good compression of past states.">

<title>SSM lacks sequence mixing – Ramblings on Deep Learning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-2e59cd003863b01633e47cbf423229e4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Ramblings on Deep Learning</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">A curious human being</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/seanxwzhang"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/seeeeaaaannnnnn"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/seanxwz/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">SSM lacks sequence mixing</h1>
                  <div>
        <div class="description">
          Every architecture contains some implicit trade-offs. My impression is SSMs are a good sequential architecture for modalities where interactions within a sequence matters less than a good compression of past states.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">deep learning</div>
                <div class="quarto-category">sequence modeling</div>
                <div class="quarto-category">technical</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Sean Zhang </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 2, 2024</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">July 22, 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><em>These are just my thoughts and intuition after tinkering with SSMs for the past month. Take with a grain of salt</em></p>
<!--more-->
<section id="opinion" class="level2">
<h2 class="anchored" data-anchor-id="opinion">Opinion</h2>
<p>Every architecture contains some implicit trade-offs. My impression is SSMs are a good sequential architecture for modalities where interactions within a sequence matters less than a good compression of past states. However, it might not be the best architecture if the following 2 conditions are met:</p>
<ol type="1">
<li>The marginal gain of additional compression quality outweighs the efficiency loss.</li>
<li><em>The way a task depends on past history varies a lot (the definition of “a lot” will become clearer later).</em></li>
</ol>
<p>The 1st condition is fairly self-explanatory and is generally true for complicated deep learning tasks (chatbot, self-driving), at least for the time being, and especially true for areas that are yet to be solved.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="quality_complexity.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="An illustration of quality-efficiency trade-off"><img src="quality_complexity.png" class="img-fluid figure-img" alt="An illustration of quality-efficiency trade-off"></a></p>
<figcaption>An illustration of quality-efficiency trade-off</figcaption>
</figure>
</div>
<p>The 2nd condition is more subtle, because what does “the way a task depends on past history” actually mean? Before attempting to answer this question, here’s why I think it matters for SSM models.</p>
<p>But even before that, let’s do a quick recap of state space models are.</p>
</section>
<section id="ssm-models" class="level2">
<h2 class="anchored" data-anchor-id="ssm-models">SSM Models</h2>
<p>When I refer to SSM models, I’m not referring to the classical <a href="https://probml.github.io/ssm-book/root.html">state space models</a> used in a control context or a quantitative finance context, but rather SSM in the context of sequential neural networks.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="ssm_literature.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Literature roadmap of recent State Space neural network Model architectures"><img src="ssm_literature.png" class="img-fluid figure-img" alt="Literature roadmap of recent State Space neural network Model architectures"></a></p>
<figcaption>Literature roadmap of recent State Space neural network Model architectures</figcaption>
</figure>
</div>
<p>The above is literature roadmap of recent SSM architectures. The are some terrific detailed explanation on what they are:</p>
<ul>
<li><a href="https://srush.github.io/annotated-s4/">The Annotated S4</a> dives deep into S4 and explained the inner workings of S4.</li>
<li><a href="https://maartengrootendorst.substack.com/p/a-visual-guide-to-mamba-and-state#%C2%A7what-problem-does-it-attempt-to-solve">A Visual Guide to Mamba and State Space Models</a> explained, visually, what mamba does.</li>
<li><a href="https://hazyresearch.stanford.edu/blog/2023-03-27-long-learning">From Deep to Long Learning?</a> where the authors themselves gave a good account of the development of H3 and Hyena.</li>
</ul>
<p>In short, SSM is the following process that models state changes of a system</p>
<p><span class="math display">\[
\begin{aligned}
\color{red}h_{t+1} &amp;= {\color{blue}A}\cdot {\color{red}{h_t}} + {\color{green}{B\cdot x_t}}\\
y_t &amp;= C\cdot {\color{red}{h_t}} + D\cdot x_t \\
\text{where } &amp;t := \text{Step/Time}\\
&amp;h := \text{Hidden state of the system} \\
&amp;x := \text{Input to the system}\\
&amp;y := \text{Output of the system} \\
&amp;A := \text{A matrix determining how the state changes over }t \\
&amp;B := \text{How input affects state} \\
&amp;C := \text{How state affects output} \\
&amp;D := \text{How input directly affects output}
\end{aligned}
\]</span></p>
<p><em>(The above is only for discrete problem, similar formulation for continuous time; Also I’m neglecting the discretization step here for illustration purpose)</em></p>
<p>There’re many properties to this model, and its usefulness is immense in the field of control, signal processing, time series application, etc.</p>
<section id="history-preserving" class="level3">
<h3 class="anchored" data-anchor-id="history-preserving">History preserving</h3>
<p>Just by laying out the equations above does not guarantee a good compression of past history. The magic of SSMs comes from the theory of approximation theory, and in particular, orthogonal polynomials <span class="citation" data-cites="chihara1978">(<a href="#ref-chihara1978" role="doc-biblioref">Chihara 1978</a>)</span>. Consider a scale value <span class="math inline">\(x\)</span> that varies with sequence <span class="math inline">\(x\)</span>, i.e.,</p>
<p><span class="math display">\[
f = f(x)
\]</span></p>
<p>Suppose we want to approximate the history with a limited number of numbers <span class="math inline">\(c_1, c_2, ... c_N\)</span>, one way to achieve it is to let each <span class="math inline">\(c_n\)</span> correspond to a “basis function” <span class="math inline">\(\phi_n\)</span> and let</p>
<p><span class="math display">\[
\hat f(x) = \sum_{n=0}^N c_n\phi_n(x)
\]</span></p>
<p>The approximation error is therefore defined as</p>
<p><span class="math display">\[
\begin{aligned}
\text{Error} &amp;= ||f(x) - \hat f(x)||^2_w = \int_0^\infty(f(x) - \hat f(x))^2w(x)dx\\
\text{where } w &amp; \text{ defines a weighting function}
\end{aligned}
\]</span></p>
<p>The weighting function is added to further generalize the discussion. Expanding the error, one obtains</p>
<p><span class="math display">\[
\begin{aligned}
\mathcal{L} &amp;= \int_0^\infty(f(x) - \sum_{n=0}^Nc_n\phi_n(x))^2w(x)dx \\
&amp;=\int_0^\infty\left[f^2(x) + \sum_{i=0}^Nc_i^2\phi_i^2(x) - 2\sum_{i\neq j}c_ic_j\phi_i(x)\phi_j(x) - 2\sum_{i=0}^Nc_i\phi_i(x)f(x)\right]w(x)dx
\end{aligned}
\]</span></p>
<p>In practice, we don’t have to limit ourselves to integrating from <span class="math inline">\(0\)</span> to <span class="math inline">\(\infty\)</span>. This motivates defining the inner product in the function space</p>
<p><span class="math display">\[
\langle f, g\rangle_w := \int_a^b f(x)g(x)w(x)dx
\]</span></p>
<p>The approximation error can be further rewritten as</p>
<p><span class="math display">\[
\mathcal{L} = \langle f, f\rangle + \sum_{i}^N c_i^2\langle\phi_i, \phi_i\rangle + \sum_{i \neq j} c_ic_j\langle \phi_i, \phi_j \rangle - 2\sum_{i}^Nc_i\langle \phi_i, f\rangle
\]</span></p>
<p>Now, wouldn’t it be nice if we can eliminate some of the terms here? In fact, we can do exactly that with orthogonal polynomials<span class="math inline">\(^2\)</span>.</p>
</section>
<section id="orthogonal-polynomials" class="level3">
<h3 class="anchored" data-anchor-id="orthogonal-polynomials">Orthogonal Polynomials</h3>
<p>Orthogonal polynomials have the property that they are orthogonal to each other under the inner product definition, i.e.,</p>
<p><span class="math display">\[
\langle \phi_i, \phi_j \rangle = 0, \forall i \neq j
\]</span></p>
<p>One example would be the Legendre polynomials, which is defined over <span class="math inline">\(t \in [-1, 1]\)</span> with <span class="math inline">\(w(t) = 1\)</span>, and is of the following forms</p>
<p><span class="math display">\[
\begin{aligned}
\phi_0(x) &amp;= 1\\
\phi_1(x) &amp;= x\\
\phi_2(x) &amp;= \frac{1}{2}(3x^2 - 1)\\
\phi_3(x) &amp;= \frac12(5x^3 - 3x) \\
...\\
\phi_n(x) &amp;= \frac{1}{2^nn!}\frac{d^n}{dx^n}(x^2-1)^n
\end{aligned}
\]</span></p>
<p><em>(note: there’s one unique set of OPs for any weight function for any given interval)</em></p>
<p>With this property, the approximation error simplifies to (the 3rd term disappears)</p>
<p><span class="math display">\[
\mathcal{L} = \langle f, f\rangle + \sum_{i}^N c_i^2\langle\phi_i, \phi_i\rangle - 2\sum_{i}^Nc_i\langle \phi_i, f\rangle
\]</span></p>
<p>To simplify it further, let’s define the constant in a meaningful way by taking the gradient of <span class="math inline">\(\mathcal{L}\)</span> with respect to <span class="math inline">\(c_i\)</span> and set it to 0</p>
<p><span class="math display">\[
\begin{aligned}
\nabla_{c_i}\mathcal{L} &amp;= 2c_i\langle\phi_i, \phi_i\rangle - 2\langle\phi_i, f\rangle = 0 \\
\rightarrow c_i &amp;=\frac{\langle\phi_i, \phi_i\rangle}{\langle\phi_i, f\rangle}
\end{aligned}
\]</span></p>
<p>The above gives us a way to <strong>combine a set of orthogonal polynomials to achieve minimum approximation error with respect to any function <span class="math inline">\(f\)</span>.</strong></p>
</section>
<section id="make-the-weight-time-dependent" class="level3">
<h3 class="anchored" data-anchor-id="make-the-weight-time-dependent">Make the weight time-dependent</h3>
<p>Now, what if the weighting function is also time dependent (changes over time)? Instead of <span class="math inline">\(w(x)\)</span>, we have <span class="math inline">\(w^{(t)}(x)\)</span>. This leads to a more complicated system where everything should be defined with respect to another time. To save you some time, this leads to the following equation for the “minimization coefficient”</p>
<p><span class="math display">\[
c_n(t) = \zeta(t)^{-\frac{1}{2}}\lambda_n \int fp_n^{(t)}\frac{w^{(t)}}{\mathcal{\chi}^{(t)}}
\]</span></p>
<p>where <span class="math inline">\(p_n^{(t)}\)</span> is the basis OP used in the system, <span class="math inline">\(\chi^{(t)}(x)\)</span> is a scaling function to increase the generality of the argument, and <span class="math inline">\(\zeta(t)\)</span> is a normalization term caused by <span class="math inline">\(\chi^{(t)}\)</span>, <span class="math inline">\(w^{(t)}\)</span> is the time-varying weighting function.</p>
<p>The difference between <span class="math inline">\(t\)</span> and <span class="math inline">\(x\)</span> is plotted below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="diff_tx.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="The difference between t and x"><img src="diff_tx.png" class="img-fluid figure-img" alt="The difference between t and x"></a></p>
<figcaption>The difference between <span class="math inline">\(t\)</span> and <span class="math inline">\(x\)</span></figcaption>
</figure>
</div>
<p>Now, why on earth would we want to do this? We want to do this because we want to take the derivative of <span class="math inline">\(c_n(t)\)</span> with respect to <span class="math inline">\(t\)</span>, and hopefully derive a SSM out of it. We can do exactly that</p>
<p><span class="math display">\[
\begin{aligned}\frac{d}{d t} c_n(t)= &amp; \zeta(t)^{-\frac{1}{2}} \lambda_n \int f(x)\left(\frac{\partial}{\partial t} p_n(t, x)\right) \frac{\omega}{\chi}(t, x) \mathrm{d} x \\&amp; +\int f(x)\left(\zeta^{-\frac{1}{2}} \lambda_n p_n(t, x)\right)\left(\frac{\partial}{\partial t} \frac{\omega}{\chi}(t, x)\right) \mathrm{d} x .\end{aligned}
\]</span></p>
<p>The beauty here is that <span class="math inline">\(\frac{\partial}{\partial t} p_n(t, x)\)</span> and <span class="math inline">\(\frac{\partial}{\partial t} \frac{\omega}{\chi}(t, x)\)</span> can both be expressed in close-form and related back to themselves, which means we get an ODE out of this!</p>
<p>Once an ODE is obtained, we can structure it to form an SSM. <strong>Note that the precise form of SSM depends on what weighting function/OP we use</strong>. Different choice of weighting function represents how we weight the history.</p>
<p>Here’s an example of the explicit form of SSM, for the Laguerre polynomials</p>
<p><span class="math display">\[
\begin{aligned}\frac{d}{d t} c(t) &amp; =-A c(t)+B f(t) \\A &amp; =\left[\begin{array}{cccc}\frac{1+\beta}{2} &amp; 0 &amp; \ldots &amp; 0 \\1 &amp; \frac{1+\beta}{2} &amp; \ldots &amp; 0 \\\vdots &amp; &amp; \ddots &amp; \\1 &amp; 1 &amp; \ldots &amp; \frac{1+\beta}{2}\end{array}\right] \\B &amp; =\zeta^{-\frac{1}{2}} \cdot\left[\begin{array}{c}\left(\begin{array}{c}\alpha \\0\end{array}\right) \\\vdots \\\left(\begin{array}{c}N-1+\alpha \\N-1\end{array}\right)\end{array}\right]\end{aligned}
\]</span></p>
</section>
<section id="problem" class="level3">
<h3 class="anchored" data-anchor-id="problem">Problem?</h3>
<p>After defining the SSM in the continuous domain, one needs to discretize it and turn it into actual architecture and code. However, here I want to focus on 2 properties of SSM:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>💡 1. The way that <span class="math inline">\(\color{red}{h_t}\)</span> evolves by itself is <strong>time invariant</strong> 2. The way <span class="math inline">\(\color{brown}x_t\)</span> affects <span class="math inline">\(\color{red}h_t\)</span> is <strong>additive</strong></p>
</div>
</div>
<p><em>(here I’m abusing notations by using <span class="math inline">\(h_t\)</span> and <span class="math inline">\(c(t)\)</span> interchangeably, and using <span class="math inline">\(x(t)\)</span> for <span class="math inline">\(f(t)\)</span>)</em></p>
<p>To elaborate a bit, it means</p>
<ol type="1">
<li>Without external input, this is a deterministic <strong>linear</strong> system (by design), and it’s much computationally easier to compute a linear system (i.e., convolution can be applied)</li>
<li>The expressiveness of the system is bound by <strong>linearity</strong></li>
</ol>
<p>To see why the 2nd point is true, we can expand the system equation and obtain</p>
<p><span class="math display">\[
\begin{aligned}
h_{t+1} &amp;= A h_{t} + Bx_{t} \\
&amp;= A^2h_{t-1} + ABx_{t-1} + Bx_{t} \\
&amp;= A^th_1 + A^{t-1}Bx_1 + A^{t-2}Bx_2 + ... + Bx_t
\\
y_{t} &amp;= CA^th_1 + CA^{t-1}Bx_1 + CA^{t-2}Bx_2 + ... + CBx_t + Dx_t
\end{aligned}
\]</span></p>
<p>where it’s clear <span class="math inline">\(x_{1:t}\)</span> can only affect the system state <span class="math inline">\(h\)</span> in linear fashion, if <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are fixed. Also, if <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> are fixed, <span class="math inline">\(y_t\)</span> is also affected by <span class="math inline">\(x_{1:t}\)</span> in a linear fashion.</p>
</section>
<section id="lack-of-non-linearity" class="level3">
<h3 class="anchored" data-anchor-id="lack-of-non-linearity">Lack of non-linearity</h3>
<p>It’s clear that such a system, while might be desirable for system control, is not ideal to express a complicated system that is <strong>non-linear</strong>. And it’s hard to argue that tasks like language modeling will be a linear system. In the most recent architectures (such as Mamba<span class="citation" data-cites="mamba">(<a href="#ref-mamba" role="doc-biblioref">Gu and Dao 2024</a>)</span>), this lack of expressiveness is addressed by</p>
<ol type="1">
<li>replacing <span class="math inline">\(B\)</span> with <span class="math inline">\(B(x_t)\)</span></li>
<li>replacing <span class="math inline">\(C\)</span> with <span class="math inline">\(C(x_t)\)</span></li>
<li>replacing <span class="math inline">\(D\)</span> with <span class="math inline">\(D(x_t)\)</span></li>
</ol>
<p>Therefore, the governing equation is replaced by</p>
<p><span class="math display">\[
\begin{aligned}
\color{red}h_{t+1} &amp;= {\color{blue}A}\cdot {\color{red}{h_t}} + {\color{green}{B(x_t)\cdot x_t}} \\
y_t &amp;= C(x_t)\cdot {\color{red}{h_t}} + D(x_t)\cdot x_t\\
\end{aligned}
\]</span></p>
<p>where we can fold the input <span class="math inline">\(x_t\)</span> further into <span class="math inline">\(B(x_t)\)</span> and <span class="math inline">\(D(x_t)\)</span> without loss of generality, and obtain</p>
<p><span class="math display">\[
\begin{aligned}
\color{red}h_{t+1} &amp;= {\color{blue}A}\cdot {\color{red}{h_t}} + {\color{green}{B(x_t)}} \\
y_t &amp;= C(x_t)\cdot {\color{red}{h_t}} + D(x_t)\\
\end{aligned}
\]</span></p>
<p>Similarly, we can expand the system again and obtain</p>
<p><span class="math display">\[
\begin{aligned}
h_{t+1} &amp;= A^th_1 + A^{t-1}B(x_1) + A^{t-2}B(x_2) + ... + B(x_t)
\\
y_{t} &amp;= C(x_t)A^{t-1}h_1 + C(x_t)A^{t-1}B(x_2) + C(x_t)A^{t-2}B(x_3) + ... + C(x_t)B(x_t) + D(x_t)
\end{aligned}
\]</span></p>
<p>Although this is technically a non-linear system as long as <span class="math inline">\(B(x)\)</span> or <span class="math inline">\(C(x)\)</span> or <span class="math inline">\(D(x)\)</span> is non-linear (for example, <span class="math inline">\(B(x) = \sin(x)\)</span>), <strong>this modeling does not involve any sequence-crossing terms</strong> like <span class="math inline">\(B(x_1)\cdot B(x_2)\)</span>.</p>
<p>This, in my opinion, hugely impacts the expressiveness of the system because the lack of sequence-cross in sequential modeling is similar to the lack of feature-crossing in tabular modeling, which will result in low sample efficiency.</p>
</section>
<section id="mamba-to-the-rescue" class="level3">
<h3 class="anchored" data-anchor-id="mamba-to-the-rescue">Mamba to the rescue?</h3>
<p>In the Mamba<span class="math inline">\(^1\)</span> paper, the authors (I’d argue partially) addressed this issue by:</p>
<ol type="1">
<li><p>inserting a <strong>convolution layer</strong> before <span class="math inline">\(x\)</span>, but I don’t see how that will fundamentally change the picture, because <span class="math inline">\(x_i\)</span> and <span class="math inline">\(x_j\)</span> will not interact with each other if their sequential distance is larger than the convolution kernel size.</p></li>
<li><p>having <strong>more layers</strong> so <span class="math inline">\(x_i\)</span> and <span class="math inline">\(x_j\)</span> can interact with each other at a higher layer, but this does not change the fact that on a given layer, no cross-sequence interaction can happen.</p></li>
<li><p>creating a gating layer so that <strong>an explicit sequence-crossing layer</strong> is added to the output <span class="math inline">\(y_t\)</span>, i.e.,</p>
<p><span class="math display">\[
\begin{aligned}
\text{Instead of }\quad y_t &amp;= C(x_t)h_t + D(x_t) \\
\text{Let}\quad y_t&amp;=\sigma(x_{1:t})*(C(x_t)h_t + D(x_t))
\end{aligned}
\]</span></p>
<p>which technically makes sequence-crossing possible. This is similar to GRU and LSTM. The additional expressiveness of such a gating mechanism, one can argue, is much less that attention, because the gate itself does not contain sequence-crossing terms.</p></li>
</ol>
</section>
</section>
<section id="intuition" class="level2">
<h2 class="anchored" data-anchor-id="intuition">Intuition</h2>
<p>By turning the linear SSM into an non-linear SSM, and adding these 3 additional modifications, SSM seem to perform well across many modalities (arguments can be made on the details of some of these experiment results, such as the extremely low vocab size used in the induction head<span class="citation" data-cites="induction_heads">(<a href="#ref-induction_heads" role="doc-biblioref">Olsson et al. 2022</a>)</span> task).</p>
<p>However, a pattern has emerged through the evolution of SSM models where we started off with a beautiful mathematical model (a unified compression scheme) that has theoretical guarantees on approximation error and implementation efficiency. However, due to our limited understanding of the expressiveness required for complicated domains like language, an iterative approach must be taken to move the trad-off point (illustrated below) towards one that <strong>uses the minimum complexity to achieve the required expressiveness and completeness</strong>.</p>
<p>The question then becomes “is transformer already at the best trade-off point”? For most domains?</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="complexity_trade_off.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="A visual illustration of the trade-off point"><img src="complexity_trade_off.png" class="img-fluid figure-img" alt="A visual illustration of the trade-off point"></a></p>
<figcaption>A visual illustration of the trade-off point</figcaption>
</figure>
</div>
<p><del>I have no idea.</del> (I have some ideas now!)</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-chihara1978" class="csl-entry" role="listitem">
Chihara, Th. 1978. <em>An Introduction to Orthogonal Polynomials</em>. Gordon; Breach, New York.
</div>
<div id="ref-mamba" class="csl-entry" role="listitem">
Gu, Albert, and Tri Dao. 2024. <span>“Mamba: Linear-Time Sequence Modeling with Selective State Spaces.”</span> <a href="https://arxiv.org/abs/2312.00752">https://arxiv.org/abs/2312.00752</a>.
</div>
<div id="ref-induction_heads" class="csl-entry" role="listitem">
Olsson, Catherine, Nelson Elhage, Neel Nanda, Nicholas Joseph, Nova DasSarma, Tom Henighan, Ben Mann, et al. 2022. <span>“In-Context Learning and Induction Heads.”</span> <a href="https://arxiv.org/abs/2209.11895">https://arxiv.org/abs/2209.11895</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/seanzhang\.me");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>